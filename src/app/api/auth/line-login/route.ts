import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import jwt from 'jsonwebtoken'

interface LineProfile {
  userId: string
  displayName: string
  pictureUrl?: string
  statusMessage?: string
}

interface LineLoginRequest {
  accessToken: string
  restaurantId?: string
  returnUrl?: string
  platform?: string
  updateProfile?: boolean
  isRecovery?: boolean
}

export async function POST(req: NextRequest) {
  try {
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° debugging ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö request ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
    console.log('üîç LINE Login API called');
    console.log('üìä Request headers:', {
      'content-type': req.headers.get('content-type'),
      'user-agent': req.headers.get('user-agent')?.slice(0, 100),
      'origin': req.headers.get('origin'),
      'referer': req.headers.get('referer')
    });

    // ‡∏≠‡πà‡∏≤‡∏ô request body ‡πÅ‡∏•‡∏∞ debug
    let requestBody;
    try {
      requestBody = await req.json();
      console.log('üì¶ Request body received:', {
        hasAccessToken: !!requestBody.accessToken,
        accessTokenLength: requestBody.accessToken?.length || 0,
        restaurantId: requestBody.restaurantId,
        platform: requestBody.platform,
        returnUrl: requestBody.returnUrl,
        isRecovery: requestBody.isRecovery,
        allKeys: Object.keys(requestBody)
      });
    } catch (jsonError) {
      console.error('‚ùå Failed to parse JSON body:', jsonError);
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400 }
      );
    }

    const { accessToken, restaurantId, returnUrl, isRecovery, platform, updateProfile } = requestBody;

    if (!accessToken) {
      console.error('‚ùå No access token provided in request');
      return NextResponse.json(
        { error: 'Access token is required' },
        { status: 400 }
      )
    }

    if (typeof accessToken !== 'string' || accessToken.trim() === '') {
      console.error('‚ùå Invalid access token format:', typeof accessToken, accessToken?.length);
      return NextResponse.json(
        { error: 'Access token must be a non-empty string' },
        { status: 400 }
      );
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏û‡∏•‡∏ï‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏à‡∏≤‡∏Å User-Agent ‡πÅ‡∏•‡∏∞ platform parameter
    const detectPlatform = (): 'IOS' | 'ANDROID' | 'BROWSER' => {
      // ‡πÉ‡∏ä‡πâ platform parameter ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
      if (platform) {
        const platformLower = platform.toLowerCase();
        if (platformLower === 'ios') return 'IOS';
        if (platformLower === 'android') return 'ANDROID';
        if (platformLower === 'web' || platformLower === 'browser') return 'BROWSER';
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏à‡∏≤‡∏Å User-Agent
      const userAgent = req.headers.get('user-agent') || '';
      
      if (userAgent.includes('iPhone') || userAgent.includes('iPad') || userAgent.includes('iOS')) {
        return 'IOS';
      }
      if (userAgent.includes('Android')) {
        return 'ANDROID';
      }
      
      return 'BROWSER';
    };

    const loginPlatform = detectPlatform();
    console.log(`üîê LINE Login from platform: ${loginPlatform}`);

    const loginType = isRecovery ? 'Recovery' : 'Normal';
    console.log(`üîê LINE ${loginType} Login attempt with restaurantId:`, restaurantId)

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö access token ‡∏Å‡∏±‡∏ö LINE API - ‡∏•‡∏î timeout ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
    console.log('üåê Validating access token with LINE API...');
    const lineResponse = await fetch('https://api.line.me/v2/profile', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      signal: AbortSignal.timeout(3000) // 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ timeout
    })

    if (!lineResponse.ok) {
      console.error('‚ùå LINE API error:', lineResponse.status, lineResponse.statusText);
      const errorBody = await lineResponse.text().catch(() => 'Unknown error');
      console.error('‚ùå LINE API error body:', errorBody);
      return NextResponse.json(
        { error: 'Invalid LINE access token' },
        { status: 401 }
      )
    }

    const lineProfile: LineProfile = await lineResponse.json()
    console.log('üìã LINE Profile received:', {
      userId: lineProfile.userId,
      displayName: lineProfile.displayName,
      pictureUrl: lineProfile.pictureUrl,
      statusMessage: lineProfile.statusMessage
    })

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á user ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• - ‡πÄ‡∏û‡∏¥‡πà‡∏° caching
    let user = await prisma.user.findUnique({
      where: { lineUserId: lineProfile.userId }
    })

    let isNewUser = false;
    let profileUpdated = false;

    if (!user) {
      console.log('üë§ Creating new LINE user with profile data')
      isNewUser = true;
      
      // ‡∏ï‡∏±‡πâ‡∏á role ‡πÄ‡∏õ‡πá‡∏ô CUSTOMER ‡πÄ‡∏õ‡πá‡∏ô default ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà
      const userRole = 'CUSTOMER'; // ‡πÉ‡∏ä‡πâ CUSTOMER ‡πÄ‡∏õ‡πá‡∏ô default role ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å platform
      
      console.log(`üì± Platform: ${loginPlatform}, Setting role: ${userRole}`);
      
      user = await prisma.user.create({
        data: {
          lineUserId: lineProfile.userId,
          name: lineProfile.displayName,
          image: lineProfile.pictureUrl,
          role: userRole,
          loginPlatform: loginPlatform,
          // ‡∏™‡∏£‡πâ‡∏≤‡∏á email ‡∏à‡∏≤‡∏Å LINE User ID
          email: `line_${lineProfile.userId}@line.user`
        } as any
      })
      console.log('‚úÖ New user created:', {
        id: user.id,
        name: user.name,
        image: user.image,
        role: user.role,
        platform: loginPlatform
      });
    } else {
      console.log('üë§ Existing LINE user found, checking for profile updates...')
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      const needsUpdate = 
        user.name !== lineProfile.displayName || 
        user.image !== lineProfile.pictureUrl ||
        (user as any).loginPlatform !== loginPlatform ||
        updateProfile; // ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö update ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤ settings
      
      if (needsUpdate) {
        const updateReason = updateProfile ? 'forced from settings' : 'profile data changed';
        console.log(`üîÑ Updating user profile (${updateReason})...`, {
          oldName: user.name,
          newName: lineProfile.displayName,
          oldImage: user.image,
          newImage: lineProfile.pictureUrl,
          oldPlatform: (user as any).loginPlatform,
          newPlatform: loginPlatform
        });
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å LINE ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà login
        user = await prisma.user.update({
          where: { id: user.id },
          data: {
            lineUserId: lineProfile.userId, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï lineUserId
            name: lineProfile.displayName,
            image: lineProfile.pictureUrl,
            loginPlatform: loginPlatform,
            updatedAt: new Date() // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
          } as any
        })
        profileUpdated = true;
        
        console.log('‚úÖ Profile updated successfully:', {
          id: user.id,
          name: user.name,
          image: user.image,
          lineUserId: user.lineUserId,
          loginPlatform: (user as any).loginPlatform,
          updateFromSettings: updateProfile
        });
      } else {
        console.log('‚ÑπÔ∏è Profile data unchanged, no update needed');
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏â‡∏û‡∏≤‡∏∞ updatedAt ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£ login ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        user = await prisma.user.update({
          where: { id: user.id },
          data: {
            lineUserId: lineProfile.userId, // ‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏°‡∏µ lineUserId
            loginPlatform: loginPlatform,
            updatedAt: new Date()
          } as any
        })
      }
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö session
    const jwtSecret = process.env.NEXTAUTH_SECRET
    if (!jwtSecret) {
      console.error('‚ùå JWT Secret not configured')
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      )
    }

    const sessionToken = jwt.sign(
      {
        userId: user.id,
        lineUserId: user.lineUserId,
        name: user.name,
        email: user.email,
        role: user.role,
        image: user.image,
        restaurantId: restaurantId || null
      },
      jwtSecret,
      { expiresIn: '30d' }
    )

    console.log('‚úÖ LINE Login successful for user:', user.name)

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö user role ‡πÅ‡∏•‡∏∞ restaurantId ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à redirect
    let shouldRedirectToRestaurant = false
    let finalRedirectUrl = '/'

    // ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à redirect ‡∏ï‡∏≤‡∏° role ‡∏Å‡πà‡∏≠‡∏ô
    if (user.role === 'RESTAURANT_OWNER') {
      console.log('üë®‚Äçüç≥ Restaurant owner login - redirect to restaurant management')
      finalRedirectUrl = '/restaurant'
      shouldRedirectToRestaurant = false // Restaurant owner ‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≤‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÄ‡∏°‡∏ô‡∏π
    }
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô newUser ‡∏à‡∏≤‡∏Å iOS/Android ‡πÅ‡∏•‡∏∞‡∏°‡∏µ restaurantId ‡πÉ‡∏´‡πâ redirect ‡πÑ‡∏õ‡πÄ‡∏°‡∏ô‡∏π‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
    else if (isNewUser && (loginPlatform === 'IOS' || loginPlatform === 'ANDROID') && restaurantId) {
      console.log('üì± New mobile user with restaurant, direct redirect to menu')
      shouldRedirectToRestaurant = true
      finalRedirectUrl = `/menu/${restaurantId}?from=mobile-new-user`
    }
    // ‡πÉ‡∏ä‡πâ returnUrl ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö customer ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
    else if (returnUrl && user.role === 'CUSTOMER') {
      console.log('üîÑ Using returnUrl for customer:', returnUrl)
      finalRedirectUrl = returnUrl
      if (returnUrl.includes('/menu/') || returnUrl.includes('/cart/')) {
        shouldRedirectToRestaurant = true
      }
    } 
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ restaurantId ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô customer
    else if (restaurantId && user.role === 'CUSTOMER') {
      console.log('üè™ Customer with restaurantId, redirect to menu:', restaurantId)
      shouldRedirectToRestaurant = true
      finalRedirectUrl = `/menu/${restaurantId}?from=line-signin`
    } else {
      console.log('üë§ Regular user login to home')
      finalRedirectUrl = '/'
    }

    const response = NextResponse.json({
      success: true,
      isNewUser,
      profileUpdated, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        image: user.image,
        lineUserId: user.lineUserId
      },
      lineProfile: { // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• LINE profile ‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
        displayName: lineProfile.displayName,
        pictureUrl: lineProfile.pictureUrl,
        statusMessage: lineProfile.statusMessage
      },
      redirectUrl: finalRedirectUrl,
      shouldRedirectToRestaurant,
      restaurantId: restaurantId || null
    })

    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ cookie ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö session - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏Ç‡∏∂‡πâ‡∏ô
    const cookieOptions: any = {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',
      maxAge: 30 * 24 * 60 * 60, // 30 days
      path: '/'
    };

    // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç domain configuration ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö production
    if (process.env.NODE_ENV === 'production') {
      // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ domain ‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏Ç‡∏∂‡πâ‡∏ô
      if (process.env.NEXTAUTH_URL) {
        try {
          const urlObj = new URL(process.env.NEXTAUTH_URL);
          const hostname = urlObj.hostname;
          
          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö IP address vs domain name
          const isIP = /^\d+\.\d+\.\d+\.\d+$/.test(hostname);
          
          if (!isIP) {
            const domainParts = hostname.split('.');
            if (domainParts.length > 2) {
              // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö subdomain ‡πÄ‡∏ä‡πà‡∏ô red.theredpotion.com
              const rootDomain = domainParts.slice(-2).join('.');
              cookieOptions.domain = '.' + rootDomain;
              console.log('üç™ Setting cookie domain (subdomain):', cookieOptions.domain);
            } else if (domainParts.length === 2) {
              // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö root domain ‡πÄ‡∏ä‡πà‡∏ô theredpotion.com
              cookieOptions.domain = '.' + hostname;
              console.log('üç™ Setting cookie domain (root):', cookieOptions.domain);
            }
          } else {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö IP address ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà domain
            console.log('üç™ Using IP address, no domain setting');
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Failed to parse NEXTAUTH_URL for cookie domain:', error);
        }
      }
      
      // ‡πÄ‡∏û‡∏¥‡πà‡∏° SameSite=None ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LIFF iframe
      cookieOptions.sameSite = 'none';
      cookieOptions.secure = true;
    }

    console.log('üç™ Cookie options:', {
      secure: cookieOptions.secure,
      sameSite: cookieOptions.sameSite,
      domain: cookieOptions.domain,
      maxAge: cookieOptions.maxAge,
      path: cookieOptions.path,
      httpOnly: cookieOptions.httpOnly
    });

    response.cookies.set('line-session-token', sessionToken, cookieOptions)

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° backup cookie ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö recovery (shorter lived)
    const backupCookieOptions = {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60, // 7 days
      httpOnly: false // ‡πÉ‡∏´‡πâ client access ‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô fallback
    };
    response.cookies.set('line-session-backup', JSON.stringify({
      userId: user.id,
      timestamp: Date.now()
    }), backupCookieOptions);

    return response

  } catch (error) {
    console.error('‚ùå LINE Login error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
} 